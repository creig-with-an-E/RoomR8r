{"version":3,"file":"static/webpack/static/development/pages/index.js.3fea46c061184b633c24.hot-update.js","sources":["webpack:///./pages/index.js"],"sourcesContent":["import React, { Component } from \"react\";\nimport {connect} from \"react-redux\"\nimport Router from \"next/router\"\nimport {parseCookies} from \"../lib/parseCookies\"\nimport Script from 'react-load-script';\n\nimport {ReviewCard, Layout, Spinner, SearchBar } from \"../src/components\"\nimport AddReviewForm from \"../src/modal/addReviewForm\"\nimport * as appActions from \"../store/actions/appActions\"\nimport * as authActions from \"../store/actions/authActions\"\n\nclass App extends Component {\n  static getInitialProps=({req})=>{\n    const cookie = parseCookies(req)\n    return {\n      savedToken: cookie.userToken\n    }\n  }\n\n  // constructor(props){\n  //   super(props)\n  //   this.handleScriptLoad = this.handleScriptLoad.bind(this)\n  //   this.handlePlaceSelect = this.handlePlaceSelect.bind(this)\n  // }\n\n  componentDidMount(){\n    if(!this.props.savedToken){\n      Router.replace(\"/auth\")\n    }else{\n      this.props.updateSavedToken(this.props.savedToken)\n    }\n  }\n\n  state = {\n    address: \"\",\n    modalVisible: false,\n    searchInitiated: false, //used as flag to check if user has attempted searching if so show no result \n    addressError:false,\n  };\n\n  // handleScriptLoad(){\n  //   /***loads google script on load */\n  //   // Declare Options For Autocomplete\n  //   const options = {\n  //     // types: ['(cities)'],\n  //   };\n\n  //   // Initialize Google Autocomplete\n  //   this.autocomplete = new google.maps.places.Autocomplete(\n  //     document.getElementById('autocomplete'),\n  //     options,\n  //   );\n\n  //   // Avoid paying for data that you don't need by restricting the set of\n  //   // place fields that are returned to just the address components.\n  //   this.autocomplete.setFields(['address_components']);\n\n  //   // Fire Event when a suggested name is selected\n  //   this.autocomplete.addListener('place_changed', this.handlePlaceSelect);\n  // }\n\n  // handlePlaceSelect=()=> {\n  //   // Extract City From Address Object\n  //   let addressObject = this.autocomplete.getPlace();\n  //   let address = addressObject.address_components;\n\n  //   // Check if address is valid\n  //   if (address) {\n  //     console.log(address)\n  //     // Set State\n  //     this.setState(\n  //       {\n  //         city: address[0].long_name,\n  //         // address: addressObject.formatted_address,\n  //       }\n  //     );\n  //   }\n  // }\n\n  onAddressChangeHandler = input => {\n    //handles user input and stores in local state\n    const valid = this.isValidatePostalCode(input)\n      if(valid){\n      const addDash = input.length===3 ? `${input.slice(0,3)}-${input.slice(3)}`:input\n      this.setState({\n       addressError:false,\n       address: addDash.toUpperCase()\n    })\n    return\n    }\n    this.setState({addressError:!valid})\n  };\n\n  isValidatePostalCode=(input)=>{\n    // validates the postal code to fit canadian format of X1X-X1X\n    const val = input.split(\"\") //storing the values in array\n    let valid = true\n    let counter = 0\n    val.forEach((element,index)=>{\n      /******\n        counter used to keep track of spaces where value should be digit\n        even array index is alphabetic character and odd is numeric\n        counter is not incremented after 3 so as to add dash which is not counted\n      ******/\n      if((counter % 2) !== 0){\n        if(element === \"-\"){\n          return\n        }else{\n          counter++\n          valid = valid && !isNaN(parseInt(element)) \n        }    \n      }else{\n        counter++\n        // validates the strings are in the right place by canadian postal code format\n        valid = valid && /^[A-Za-z\\-]/.test(element)\n      }\n    })\n    return valid\n  }\n  searchByAddressHandler = event => {\n    this.props.findByAddress(this.props.userToken, this.state.address)\n  }\n\n  showModalHandle=()=>{\n    this.setState({modalVisible: true})\n  }\n\n  hideModalHandle=()=>{\n    this.setState({modalVisible: false})\n  } \n  render() {\n    let cards = null\n    /**\n     *  emptyResultsText: this is used to display feedback when empty list returned.\n     *  display of this warning is handled by state.showEmptyResultsWarning flag\n     * */ \n    let emptyResultsText = \"\"\n    if(this.props.searchResults !== null && this.props.searchResults.length > 0){\n      cards= this.props.searchResults ? this.props.searchResults.map(element=><ReviewCard data={element} key={element.id} />): null\n    }else if(this.props.searchResults){\n      /*** this handle the empty array case where no results where found**/ \n      if(this.props.searchResults.length === 0){\n        emptyResultsText = <p style={styles.noResultsStyle}>Currently no reviews exist for this postal code</p>\n      }\n    }\n    const spinner = !this.props.loading ? null : <Spinner />;\n    /***  showModal handle is passed down to Layout ***/\n    return (\n      <Layout showModalHandle={this.showModalHandle}>\n        <AddReviewForm \n            userToken={this.props.userToken}\n            modalVisible={this.state.modalVisible}\n            hideModalHandle={this.hideModalHandle}>\n        </AddReviewForm>\n        <section style={styles.sectionStyle}>\n        <h2 style={styles.headerStyle}>\n            Because not all landlords are built the same\n          </h2>\n          {/* <SearchBar\n            id=\"autocomplete\"\n            invalid={this.state.addressError ? true : false}\n            placeholder=\"X5X-X5X\"\n            value={this.state.address}\n            // onChange={this.onAddressChangeHandler}\n            onRequestSearch={this.searchByAddressHandler}\n          /> */}\n          <p style={styles.errorStyle}> {this.state.addressError ? \"Acceptable format is X9X-9X9\" : \"\"} </p>\n          <p style={styles.searchHeading}>Search for reviews by Postal Code</p>\n          {spinner}\n          {emptyResultsText}\n        <div style={{ width:\"100%\"}}>{cards}</div>\n        </section>            \n      </Layout>\n    );\n  }\n}\n\nconst styles = {\n  headerStyle:{\n    marginTop:\"80px\",\n    fontSize: 22,\n    color: \"rgb(44,54,94)\",\n    textAlign: \"center\",\n    fontFamily:'Poppins, sans-serif',\n    fontWeight:\"bold\"\n  },\n  sectionStyle:{\n    overflowY:\"scroll\",\n    alignSelf:\"center\",\n    marginTop:\"5px\",\n    padding: \"20px\",\n    textAlign: \"center\",\n    width:\"100%\"\n  },\n  searchHeading:{\n    fontSize:16,\n    marginTop:20,\n    color: \"rgb(44,54,94)\", \n    fontWeight:\"bold\",\n    fontFamily:\"Poppins, sans serif\"\n  },\n  errorStyle:{\n    color:\"rgb(255,89,65)\",\n    fontWeight:\"bold\",\n    fontFamily:\"Poppins, sans serif\"\n  },\n  noResultsStyle:{\n    color:\"rgb(255,89,65)\",\n    fontSize:20,\n    fontWeight:\"bold\",\n    fontFamily:\"Fira Sans, sans serif\"\n  }\n};\n\nconst mapStateToProps=(state)=>{\n  return{\n    userToken: state.auth.userToken,\n    searchResults:state.app.searchResults,\n    loading: state.app.loading\n  }\n}\n\nconst mapDispatchToProps=(dispatch)=>{\n  return{\n    updateSavedToken:(token)=>dispatch(authActions.updateSavedToken(token)),\n    findByAddress:(userToken,address)=>dispatch(appActions.findReviewByAddress(userToken,address))\n  }\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(App);\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AAsBA;AACA;AACA;AACA;AAAA;AACA;AAJA;AACA;AA6CA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAFA;AACA;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;;;;;;AA/GA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAmGA;AACA;AACA;;;;;AAIA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;;;;AAnKA;AACA;AADA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AA+JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AAJA;AA7BA;AACA;AAoCA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAFA;AAIA;AACA;AACA;;;;A","sourceRoot":""}